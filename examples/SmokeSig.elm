module Contracts.SmokeSig exposing
    ( SmokeSignalWithMessage
    , SmokeSignalWithoutMessage
    , amountBurnedForSignal
    , smokeSignalWithHash
    , smokeSignalWithMessage
    , smokeSignalWithMessageDecoder
    , smokeSignalWithMessageEvent
    , smokeSignalWithoutMessageDecoder
    , smokeSignalWithoutMessageEvent
    , token
    )

import Eth.Abi.Decode as D exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Eth.Abi.Encode as E exposing (Encoding(..), abiEncode)
import BigInt exposing (BigInt)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator v3.0.1
   Compatible with elm-ethereum v4.0.0

-}
-- amountBurnedForSignal(bytes32) function


amountBurnedForSignal : Address -> Hex -> Call BigInt
amountBurnedForSignal contractAddress a_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "9f00fd4d" [ (E.staticBytes 32) a_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.uint
    }


-- smokeSignalWithHash(bytes32,uint256) function


smokeSignalWithHash : Address -> Hex -> BigInt -> Call ()
smokeSignalWithHash contractAddress hash_ burnAmount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "19ae54eb" [ (E.staticBytes 32) hash_, E.uint burnAmount_ ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


-- smokeSignalWithMessage(string,uint256) function


smokeSignalWithMessage : Address -> String -> BigInt -> Call Hex
smokeSignalWithMessage contractAddress message_ burnAmount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "35bf65b2" [ E.string message_, E.uint burnAmount_ ]
    , nonce = Nothing
    , decoder = toElmDecoder (D.staticBytes 32)
    }


-- token() function


token : Address -> Call Address
token contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "fc0c546a" []
    , nonce = Nothing
    , decoder = toElmDecoder D.address
    }


-- SmokeSignalWithMessage(bytes32,address,uint256,string) event


type alias SmokeSignalWithMessage =
    { hash : Hex
    , from : Address
    , burnAmount : BigInt
    , message : String
    }


smokeSignalWithMessageEvent : Address -> Maybe Hex -> Maybe Address -> LogFilter
smokeSignalWithMessageEvent contractAddress hash_ from_ = 
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics = 
        [ Just <| U.unsafeToHex "52dc870e81fddee260ec96189fd5cc37b232d3667f3dab2372a3d98301364976"
        , Maybe.map (abiEncode << (E.staticBytes 32)) hash_
        , Maybe.map (abiEncode << E.address) from_
        ]
    }


smokeSignalWithMessageDecoder : Decoder SmokeSignalWithMessage
smokeSignalWithMessageDecoder = 
    Decode.succeed SmokeSignalWithMessage
        |> custom (topic 1 (D.staticBytes 32))
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)
        |> custom (data 1 D.string)


-- SmokeSignalWithoutMessage(bytes32,address,uint256) event


type alias SmokeSignalWithoutMessage =
    { hash : Hex
    , from : Address
    , burnAmount : BigInt
    }


smokeSignalWithoutMessageEvent : Address -> Maybe Hex -> Maybe Address -> LogFilter
smokeSignalWithoutMessageEvent contractAddress hash_ from_ = 
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics = 
        [ Just <| U.unsafeToHex "139354f151d35bd99216f6ab24ac33a21c06e704b9d92c01e44f1c8357495044"
        , Maybe.map (abiEncode << (E.staticBytes 32)) hash_
        , Maybe.map (abiEncode << E.address) from_
        ]
    }


smokeSignalWithoutMessageDecoder : Decoder SmokeSignalWithoutMessage
smokeSignalWithoutMessageDecoder = 
    Decode.succeed SmokeSignalWithoutMessage
        |> custom (topic 1 (D.staticBytes 32))
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)


